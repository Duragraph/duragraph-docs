---
title: Server-Sent Events (SSE) Streaming
description: Real-time event streaming documentation
---

DuraGraph provides real-time updates via Server-Sent Events (SSE) for monitoring workflow execution, LLM token streaming, and system events.

## Overview

SSE allows clients to receive push notifications from the server over a single HTTP connection. Perfect for:

- Real-time run status updates
- LLM token-by-token streaming
- Live workflow progress monitoring
- Event-driven UIs

## Endpoint

```http
GET /api/v1/stream?run_id={run_id}
```

**Query Parameters:**

- `run_id` (required) - The run ID to stream events for

## Connection

### cURL

```bash
curl -N http://localhost:8081/api/v1/stream?run_id={run_id}
```

The `-N` flag disables buffering for immediate event delivery.

### Python

```python
import requests

run_id = "323e4567-e89b-12d3-a456-426614174000"
url = f"http://localhost:8081/api/v1/stream?run_id={run_id}"

with requests.get(url, stream=True) as response:
    for line in response.iter_lines():
        if line:
            decoded = line.decode('utf-8')
            if decoded.startswith('data: '):
                data = decoded[6:]  # Remove 'data: ' prefix
                print(data)
```

### JavaScript

```javascript
const runId = '323e4567-e89b-12d3-a456-426614174000';
const eventSource = new EventSource(`http://localhost:8081/api/v1/stream?run_id=${runId}`);

eventSource.onmessage = (event) => {
  const data = JSON.parse(event.data);
  console.log('Event:', data);
};

eventSource.addEventListener('run.completed', (event) => {
  const data = JSON.parse(event.data);
  console.log('Run completed:', data);
  eventSource.close();
});

eventSource.onerror = (error) => {
  console.error('SSE error:', error);
  eventSource.close();
};
```

### Go

```go
package main

import (
    "bufio"
    "fmt"
    "net/http"
    "strings"
)

func streamEvents(runID string) error {
    url := fmt.Sprintf("http://localhost:8081/api/v1/stream?run_id=%s", runID)

    resp, err := http.Get(url)
    if err != nil {
        return err
    }
    defer resp.Body.Close()

    scanner := bufio.NewScanner(resp.Body)
    for scanner.Scan() {
        line := scanner.Text()
        if strings.HasPrefix(line, "data: ") {
            data := strings.TrimPrefix(line, "data: ")
            fmt.Println("Event:", data)
        }
    }

    return scanner.Err()
}
```

## Event Types

### Run Events

#### `run.started`

Emitted when run execution begins.

```json
{
  "type": "run.started",
  "run_id": "323e4567-e89b-12d3-a456-426614174000",
  "timestamp": "2025-01-03T12:00:00Z"
}
```

#### `run.completed`

Emitted when run finishes successfully.

```json
{
  "type": "run.completed",
  "run_id": "323e4567-e89b-12d3-a456-426614174000",
  "output": {
    "result": "Task completed"
  },
  "timestamp": "2025-01-03T12:00:30Z"
}
```

#### `run.failed`

Emitted when run fails with an error.

```json
{
  "type": "run.failed",
  "run_id": "323e4567-e89b-12d3-a456-426614174000",
  "error": {
    "code": "execution_error",
    "message": "Node execution failed",
    "details": {}
  },
  "timestamp": "2025-01-03T12:00:15Z"
}
```

#### `run.requires_action`

Emitted when run needs human input or tool outputs.

```json
{
  "type": "run.requires_action",
  "run_id": "323e4567-e89b-12d3-a456-426614174000",
  "required_action": {
    "type": "submit_tool_outputs",
    "submit_tool_outputs": {
      "tool_calls": [
        {
          "id": "call_abc123",
          "type": "function",
          "function": {
            "name": "web_search",
            "arguments": "{\"query\": \"AI agents\"}"
          }
        }
      ]
    }
  },
  "timestamp": "2025-01-03T12:00:10Z"
}
```

### Node Events

#### `node.started`

Emitted when a node begins execution.

```json
{
  "type": "node.started",
  "run_id": "323e4567-e89b-12d3-a456-426614174000",
  "node_id": "process_input",
  "node_type": "llm",
  "timestamp": "2025-01-03T12:00:05Z"
}
```

#### `node.completed`

Emitted when a node finishes execution.

```json
{
  "type": "node.completed",
  "run_id": "323e4567-e89b-12d3-a456-426614174000",
  "node_id": "process_input",
  "output": {
    "result": "Processed"
  },
  "timestamp": "2025-01-03T12:00:08Z"
}
```

### LLM Events

#### `llm.token`

Emitted for each token generated by LLM (streaming mode).

```json
{
  "type": "llm.token",
  "run_id": "323e4567-e89b-12d3-a456-426614174000",
  "node_id": "generate_response",
  "token": "Hello",
  "timestamp": "2025-01-03T12:00:06.123Z"
}
```

#### `llm.completion`

Emitted when LLM completes generation.

```json
{
  "type": "llm.completion",
  "run_id": "323e4567-e89b-12d3-a456-426614174000",
  "node_id": "generate_response",
  "content": "Hello! How can I help you today?",
  "model": "gpt-4o-mini",
  "usage": {
    "prompt_tokens": 10,
    "completion_tokens": 8,
    "total_tokens": 18
  },
  "timestamp": "2025-01-03T12:00:08Z"
}
```

### Tool Events

#### `tool.call`

Emitted when a tool is called.

```json
{
  "type": "tool.call",
  "run_id": "323e4567-e89b-12d3-a456-426614174000",
  "tool_call_id": "call_abc123",
  "tool_name": "web_search",
  "arguments": {
    "query": "AI agents"
  },
  "timestamp": "2025-01-03T12:00:10Z"
}
```

#### `tool.result`

Emitted when tool execution completes.

```json
{
  "type": "tool.result",
  "run_id": "323e4567-e89b-12d3-a456-426614174000",
  "tool_call_id": "call_abc123",
  "result": {
    "results": [...]
  },
  "timestamp": "2025-01-03T12:00:12Z"
}
```

### Checkpoint Events

#### `checkpoint.saved`

Emitted when workflow state is checkpointed.

```json
{
  "type": "checkpoint.saved",
  "run_id": "323e4567-e89b-12d3-a456-426614174000",
  "checkpoint_id": "chk_abc123",
  "timestamp": "2025-01-03T12:00:10Z"
}
```

### System Events

#### `heartbeat`

Periodic keepalive event (every 30 seconds).

```json
{
  "type": "heartbeat",
  "timestamp": "2025-01-03T12:00:30Z"
}
```

#### `error`

Emitted for non-fatal errors.

```json
{
  "type": "error",
  "run_id": "323e4567-e89b-12d3-a456-426614174000",
  "error": {
    "message": "Warning: Rate limit approaching"
  },
  "timestamp": "2025-01-03T12:00:15Z"
}
```

## Event Flow Example

Typical event sequence for a successful run:

```
data: {"type":"run.started","run_id":"..."}

data: {"type":"node.started","node_id":"input"}

data: {"type":"node.completed","node_id":"input"}

data: {"type":"checkpoint.saved","checkpoint_id":"chk_1"}

data: {"type":"node.started","node_id":"llm"}

data: {"type":"llm.token","token":"Hello"}
data: {"type":"llm.token","token":" there"}
data: {"type":"llm.token","token":"!"}

data: {"type":"llm.completion","content":"Hello there!"}

data: {"type":"node.completed","node_id":"llm"}

data: {"type":"checkpoint.saved","checkpoint_id":"chk_2"}

data: {"type":"run.completed","output":{"result":"..."}}
```

## Best Practices

### Reconnection

Implement automatic reconnection with exponential backoff:

```javascript
class SSEClient {
  constructor(url) {
    this.url = url;
    this.retryDelay = 1000;
    this.maxRetryDelay = 30000;
  }

  connect() {
    this.eventSource = new EventSource(this.url);

    this.eventSource.onerror = () => {
      this.eventSource.close();

      setTimeout(() => {
        this.retryDelay = Math.min(this.retryDelay * 2, this.maxRetryDelay);
        this.connect();
      }, this.retryDelay);
    };

    this.eventSource.onopen = () => {
      this.retryDelay = 1000; // Reset on successful connection
    };
  }
}
```

### Event Filtering

Filter events client-side for specific types:

```python
def stream_llm_tokens(run_id):
    url = f"http://localhost:8081/api/v1/stream?run_id={run_id}"

    with requests.get(url, stream=True) as response:
        for line in response.iter_lines():
            if line:
                decoded = line.decode('utf-8')
                if decoded.startswith('data: '):
                    data = json.loads(decoded[6:])

                    # Only process LLM tokens
                    if data.get('type') == 'llm.token':
                        print(data['token'], end='', flush=True)
```

### Timeout Handling

Set appropriate timeouts:

```python
import requests
from requests.adapters import HTTPAdapter
from requests.packages.urllib3.util.retry import Retry

session = requests.Session()
retry = Retry(total=3, backoff_factor=1)
adapter = HTTPAdapter(max_retries=retry)
session.mount('http://', adapter)

response = session.get(
    url,
    stream=True,
    timeout=(5, None)  # 5s connect timeout, no read timeout
)
```

### Resource Cleanup

Always close connections when done:

```javascript
const eventSource = new EventSource(url);

// Close on completion
eventSource.addEventListener('run.completed', () => {
  eventSource.close();
});

// Close on page unload
window.addEventListener('beforeunload', () => {
  eventSource.close();
});
```

## Error Handling

### Connection Errors

```javascript
eventSource.onerror = (error) => {
  if (eventSource.readyState === EventSource.CLOSED) {
    console.error('Connection closed');
    // Implement reconnection logic
  } else {
    console.error('SSE error:', error);
  }
};
```

### Invalid Run ID

```
HTTP/1.1 404 Not Found
Content-Type: application/json

{
  "error": "resource_not_found",
  "message": "Run not found"
}
```

### Authentication Error

```
HTTP/1.1 401 Unauthorized
Content-Type: application/json

{
  "error": "unauthorized",
  "message": "Missing or invalid API key"
}
```

## Performance Considerations

### Client-Side Buffering

For token streaming, buffer tokens for smoother rendering:

```javascript
let buffer = '';
let bufferTimeout;

eventSource.addEventListener('llm.token', (event) => {
  const data = JSON.parse(event.data);
  buffer += data.token;

  clearTimeout(bufferTimeout);
  bufferTimeout = setTimeout(() => {
    updateUI(buffer);
    buffer = '';
  }, 50); // Flush every 50ms
});
```

### Memory Management

Limit event history to prevent memory leaks:

```javascript
const MAX_EVENTS = 1000;
const events = [];

eventSource.onmessage = (event) => {
  const data = JSON.parse(event.data);
  events.push(data);

  if (events.length > MAX_EVENTS) {
    events.shift(); // Remove oldest event
  }
};
```

## Testing

### Manual Testing

```bash
# Test basic connection
curl -N http://localhost:8081/api/v1/stream?run_id={run_id}

# Test with timeout
timeout 30s curl -N http://localhost:8081/api/v1/stream?run_id={run_id}

# Save events to file
curl -N http://localhost:8081/api/v1/stream?run_id={run_id} > events.log
```

### Integration Testing

```python
import pytest
import requests

def test_sse_stream():
    # Create run
    run = create_test_run()

    # Stream events
    url = f"http://localhost:8081/api/v1/stream?run_id={run['run_id']}"
    events = []

    with requests.get(url, stream=True, timeout=30) as response:
        for line in response.iter_lines():
            if line:
                decoded = line.decode('utf-8')
                if decoded.startswith('data: '):
                    data = json.loads(decoded[6:])
                    events.append(data)

                    # Stop after completion
                    if data.get('type') == 'run.completed':
                        break

    # Verify event sequence
    assert events[0]['type'] == 'run.started'
    assert events[-1]['type'] == 'run.completed'
```

## Examples

### Real-time Chat UI

```javascript
class ChatStream {
  constructor(runId) {
    this.runId = runId;
    this.messageContainer = document.getElementById('messages');
    this.currentMessage = '';
  }

  start() {
    const url = `/api/v1/stream?run_id=${this.runId}`;
    this.eventSource = new EventSource(url);

    this.eventSource.addEventListener('llm.token', (event) => {
      const data = JSON.parse(event.data);
      this.currentMessage += data.token;
      this.updateMessageDisplay();
    });

    this.eventSource.addEventListener('llm.completion', (event) => {
      this.finalizeMessage();
    });

    this.eventSource.addEventListener('run.completed', (event) => {
      this.eventSource.close();
    });
  }

  updateMessageDisplay() {
    // Update UI with streaming text
    this.messageContainer.textContent = this.currentMessage;
  }

  finalizeMessage() {
    // Finalize message display
    this.messageContainer.classList.add('complete');
  }
}
```

### Progress Tracking

```python
def track_progress(run_id):
    url = f"http://localhost:8081/api/v1/stream?run_id={run_id}"
    nodes_completed = set()

    with requests.get(url, stream=True) as response:
        for line in response.iter_lines():
            if line:
                decoded = line.decode('utf-8')
                if decoded.startswith('data: '):
                    data = json.loads(decoded[6:])

                    if data.get('type') == 'node.completed':
                        node_id = data['node_id']
                        nodes_completed.add(node_id)
                        print(f"Progress: {len(nodes_completed)} nodes completed")

                    elif data.get('type') == 'run.completed':
                        print("Run completed!")
                        break
```

## Next Steps

- [REST API Reference](/docs/api-reference/rest-api) - Complete endpoint docs
- [Webhooks](/docs/api-reference/webhooks) - Alternative event delivery
- [Examples](/docs/api-reference/examples) - More code samples
